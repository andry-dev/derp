<div class="container-fluid" x-data="reviewData">
      <%= if @current_user do %>
        <div class="row mt-4">

            <div class="col col-sm-8">
              <h1>Reviews</h1>
            </div>

            <div class="col col-sm-4">
              <%= link "New Review", to: Routes.review_path(@conn, :new), class: "btn btn-primary" %>
              <button class="btn btn-primary" id="refreshReviews" @click="refresh()">Refresh reviews</button>
            </div>
        </div>

        <div class="row">
            <div class="col col-md-12">
              <table class="table table-hover mt-3">
                <thead>
                  <tr>
                    <th>Product photo</th>
                    <th>Title</th>
                    <th>Body</th>
                    <th>Upvotes</th>
                    <th>Downvotes <small>(not publicly shown)</small></th>
                    <!-- <th>Ipfs hash</th> -->

                    <th></th>
                  </tr>
                </thead>
                <tbody>

                <template x-for="review in reviews">
                  <tr>
                    <td x-text="review.product_id"></td>
                    <td x-text="review.title"></td>
                    <td x-text="review.body"></td>
                    <td x-text="review.upvotes"></td>
                    <td x-text="review.downvotes"></td>
                  </tr>
                </template>
                </tbody>
              </table>
            </div>
        </div>
      <% else %>
        <div class="row mt-4">
            <div class="col col-md-12">
              <p class="text-center">Please log in to see reviews</p>
            </div>
        </div>
      <% end %>
</div>


<script>
    document.addEventListener('alpine:init', () => {
        Alpine.data('reviewData', () => ({
            reviews: [ ],

            async init() {
              await this.refresh();
            },

            async refresh() {
              if (!window.contract) {
                await ethEnabled();
              }

              const reviewHashes = await contract.methods.getReviews().call();
              //console.log(reviewHashes)

              for (i = 0; i < reviewHashes.length; i++) {

                //console.log(reviewHashes[i])
                const asciiAddress = web3.utils.hexToAscii(reviewHashes[i])
                //console.log(asciiAddress)
                const stream = await ipfs.cat(asciiAddress);

                const decoder = new TextDecoder()
                let data = ''

                for await (const chunk of stream) {
                  // chunks of data are returned as a Uint8Array, convert it back to a string
                  data += decoder.decode(chunk, { stream: true })
                }

                const json_data = JSON.parse(data);

                this.reviews.push({
                  product_id: json_data.productNumber,
                  title: json_data.reviewTitle,
                  body: json_data.reviewBody,
                  upvotes: 1,
                  downvotes: 0,
                });
              }
            }
        }))
    })
</script>
